import type { Meta, StoryObj } from '@storybook/react-vite';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import SPARQLQuerySection from '../../src/components/AI/SPARQLQuerySection';
import { DynamicQuestionProvider } from '../../src/context/DynamicQuestionContext';
import questionReducer from '../../src/store/slices/questionSlice';
import aiReducer from '../../src/store/slices/aiSlice';

const mockStore = configureStore({
  reducer: {
    questions: questionReducer,
    ai: aiReducer,
  },
});

const meta: Meta<typeof SPARQLQuerySection> = {
  title: 'AI/SPARQLQuerySection',
  component: SPARQLQuerySection,
  tags: ['autodocs'],
  parameters: {
    docs: {
      description: {
        component:
          '`SPARQLQuerySection` provides a comprehensive interface for entering research questions and managing SPARQL queries against the ORKG triplestore. It supports manual query editing via CodeEditor, AI-assisted modifications through a dialog, query execution, and displays query explanations with predicate/class metadata extracted from ORKG templates. The component also shows template insights including predicate descriptions, class hierarchies, and resource metadata fetched from the ORKG API.',
      },
    },
  },
  argTypes: {
    question: {
      control: 'text',
      description:
        'The research question text entered by the user. This drives the AI query generation and provides context for the SPARQL query. Displayed in a multiline TextField at the top of the component.',
      table: {
        type: { summary: 'string' },
      },
    },
    sparqlQuery: {
      control: 'text',
      description:
        'The SPARQL query string to be executed against the ORKG triplestore. Uses ORKG-specific prefixes (orkgp, orkgc, orkgr) for predicates, classes, and resources. Displayed in a CodeEditor component with syntax highlighting.',
      table: {
        type: { summary: 'string' },
      },
    },
    sparqlTranslation: {
      control: 'text',
      description:
        'Natural language translation/explanation of what the SPARQL query does. Generated by AI to help users understand the query logic without needing SPARQL expertise.',
      table: {
        type: { summary: 'string' },
      },
    },
    loading: {
      control: 'boolean',
      description:
        'Controls the loading state of the component. When true, disables the question input and shows loading indicators on action buttons. Used during query generation and execution.',
      table: {
        type: { summary: 'boolean' },
        defaultValue: { summary: 'false' },
      },
    },
    queryResults: {
      control: 'object',
      description:
        'Array of SPARQL result binding objects returned from query execution. Each object contains variable bindings with `.value` properties. Used to display result count and provide context for AI modifications.',
      table: {
        type: { summary: 'Record<string, unknown>[]' },
        defaultValue: { summary: '[]' },
      },
    },
    queryError: {
      control: 'text',
      description:
        'Error message string if the SPARQL query execution failed. Displayed as an Alert component. Common errors include syntax errors, timeout, or connection issues with the ORKG triplestore.',
      table: {
        type: { summary: 'string | null' },
        defaultValue: { summary: 'null' },
      },
    },
    onQuestionChange: {
      action: 'questionChanged',
      description:
        'Callback fired when the research question text is modified. Receives the new question string. Parent should update state to reflect the change.',
      table: {
        type: { summary: '(question: string) => void' },
      },
    },
    onSparqlChange: {
      action: 'sparqlChanged',
      description:
        'Callback fired when the SPARQL query is modified, either manually or via AI. Receives the new query string. Parent should update state and may trigger re-execution.',
      table: {
        type: { summary: '(sparql: string) => void' },
      },
    },
    onGenerateAndRun: {
      action: 'generateAndRun',
      description:
        'Callback fired when the "Generate and Run Query" button is clicked. Triggers AI generation of a SPARQL query based on the research question, followed by execution against the ORKG triplestore.',
      table: {
        type: { summary: '() => void' },
      },
    },
    onRunEditedQuery: {
      action: 'runEditedQuery',
      description:
        'Callback fired when the user wants to run a manually edited query. Executes the current SPARQL query without regenerating it.',
      table: {
        type: { summary: '() => void' },
      },
    },
    onOpenHistory: {
      action: 'openHistory',
      description:
        "Callback fired when the history button is clicked. Opens a dialog showing previous versions of either the question or SPARQL query. Receives the history type ('query' or 'sparql') as argument.",
      table: {
        type: { summary: "(type: 'query' | 'sparql') => void" },
      },
    },
    templateMapping: {
      control: 'object',
      description:
        'PredicatesMapping object from ORKG template analysis. Contains predicate metadata including labels, descriptions, cardinality, and nested subtemplate properties. Used to display query explanation insights.',
      table: {
        type: { summary: 'PredicatesMapping' },
      },
    },
    templateId: {
      control: 'text',
      description:
        'The ORKG template resource ID (e.g., "R123456") currently being used for query generation. Displayed in the query explanation section.',
      table: {
        type: { summary: 'string | null' },
      },
    },
    targetClassId: {
      control: 'text',
      description:
        'The target ORKG class ID (e.g., "C12345") that the query is filtering for. Used in template insights to show the primary class being queried.',
      table: {
        type: { summary: 'string | null' },
      },
    },
  },
  decorators: [
    (Story) => (
      <Provider store={mockStore}>
        <DynamicQuestionProvider>
          <div style={{ maxWidth: '1000px', padding: '20px' }}>
            <Story />
          </div>
        </DynamicQuestionProvider>
      </Provider>
    ),
  ],
};

export default meta;
type Story = StoryObj<typeof SPARQLQuerySection>;

// research question for ORKG analysis
const sampleQuestion =
  'How has the number of empirical studies in Requirements Engineering evolved over the years?';

// SPARQL query using ORKG prefixes and predicates
const sampleSparqlQuery = `PREFIX orkgp: <http://orkg.org/orkg/predicate/>
PREFIX orkgc: <http://orkg.org/orkg/class/>
PREFIX orkgr: <http://orkg.org/orkg/resource/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?year (COUNT(DISTINCT ?paper) AS ?paperCount)
WHERE {
  # Find papers that are contributions to the KG-EmpiRE template
  ?contribution orkgp:P31 orkgr:R54312 .
  ?paper orkgp:P31 ?contribution .
  
  # Get publication year
  ?paper orkgp:P29 ?year .
  
  # Filter for valid years
  FILTER(BOUND(?year) && ?year != "")
}
GROUP BY ?year
ORDER BY ?year`;

const sampleTranslation =
  'This query counts the number of distinct papers per publication year that have contributions linked to the KG-EmpiRE template (R54312). It groups results by year and orders them chronologically to show the evolution of empirical studies over time.';

// SPARQL results
const sampleResults = [
  { year: '2018', paperCount: '45' },
  { year: '2019', paperCount: '62' },
  { year: '2020', paperCount: '78' },
  { year: '2021', paperCount: '95' },
  { year: '2022', paperCount: '124' },
  { year: '2023', paperCount: '156' },
];

// Sample template mapping
const sampleTemplateMapping = {
  P31: {
    predicate_label: 'Has contribution',
    label: 'Contribution',
    description: 'Links a paper to its research contribution',
    cardinality: '1..*',
    class_id: 'C12345',
    class_label: 'Contribution',
  },
  P29: {
    predicate_label: 'Publication year',
    label: 'Year',
    description: 'The year when the paper was published',
    cardinality: '1',
    class_id: undefined,
    class_label: undefined,
  },
  P30: {
    predicate_label: 'Published in',
    label: 'Venue',
    description:
      'The venue (journal, conference) where the paper was published',
    cardinality: '0..1',
    class_id: 'C5678',
    class_label: 'Venue',
  },
};

export const Default: Story = {
  args: {
    question: sampleQuestion,
    sparqlQuery: sampleSparqlQuery,
    sparqlTranslation: sampleTranslation,
    loading: false,
    queryResults: [],
    queryError: null,
    templateId: 'R54312',
    targetClassId: 'C12345',
    templateMapping: sampleTemplateMapping,
  },
  parameters: {
    docs: {
      description: {
        story:
          'Default view with a research question about empirical studies and a SPARQL query ready for execution. Shows the query editor with ORKG-specific prefixes and predicates. The template mapping provides context for the query explanation feature.',
      },
    },
  },
};

export const WithResults: Story = {
  args: {
    question: sampleQuestion,
    sparqlQuery: sampleSparqlQuery,
    sparqlTranslation: sampleTranslation,
    loading: false,
    queryResults: sampleResults,
    queryError: null,
    templateId: 'R54312',
    targetClassId: 'C12345',
    templateMapping: sampleTemplateMapping,
  },
  parameters: {
    docs: {
      description: {
        story:
          'SPARQL query section after successful execution, showing the result count badge. The results array contains SPARQL binding objects with year and paperCount values from the ORKG triplestore.',
      },
    },
  },
};

export const WithError: Story = {
  args: {
    question: sampleQuestion,
    sparqlQuery: sampleSparqlQuery,
    sparqlTranslation: sampleTranslation,
    loading: false,
    queryResults: [],
    queryError:
      'SPARQL syntax error at line 12: Unexpected token "GROUPBY". Expected "GROUP BY" with space. Query execution failed after 30 seconds timeout.',
  },
  parameters: {
    docs: {
      description: {
        story:
          'Error state displaying a SPARQL syntax error message. Common errors include syntax issues, malformed URIs, timeout errors, or connection problems with the ORKG triplestore endpoint.',
      },
    },
  },
};
